import fs from 'fs'
import path from 'path'
import { logger } from '../../core/utils'
import type { Severity } from '../types'

export interface ActionExecutorOptions {
  stateManager?: unknown
  namespace: string
}

let activePause: NodeJS.Timeout | null = null

export async function executeCreatePRD(
  match: RegExpMatchArray,
  taskId: string,
  _options: ActionExecutorOptions
): Promise<void> {
  try {
    const prdPath = path.join(process.cwd(), '.specs', 'tasks', `${taskId}.md`)
    const tasksJsonPath = path.join(process.cwd(), '.specs', 'tasks', 'tasks.json')

    if (await fileExists(prdPath)) {
      logger.warn(`PRD already exists: ${prdPath}`)
      return
    }

    await ensureDir(path.dirname(prdPath))

    const prdContent = `# ${taskId}

## Goal
Auto-generated PRD - task description was missing or incomplete.

## Requirements
- Review the task context from execution logs
- Add specific requirements and success criteria
- Ensure the task has clear acceptance criteria

## Notes
This PRD was auto-generated by the AI Monitor.
Please review and update with proper task description before execution.

---

**Auto-created by: AI Monitor**
**Reason: PRD file not found**

---

## Context from Execution Logs

*(Task execution attempted but PRD was missing. Review logs for what was attempted and what was needed.)*

`

    await writeFile(prdPath, prdContent, 'utf-8')
    logger.info(`Created missing PRD: ${prdPath}`)

    await updateTaskDescription(taskId, prdContent, tasksJsonPath)
  } catch (error) {
    logger.error(`Failed to create PRD for ${match[1]}: ${error}`)
    throw error
  }
}

export async function executePause(
  reason: string,
  duration: number,
  options: ActionExecutorOptions
): Promise<void> {
  const { namespace, stateManager } = options

  try {
    logger.warn(`[AI-MONITOR] Pausing loop for ${duration}ms: ${reason}`)

    const pauseInfo = {
      paused: true,
      reason,
      durationMs: duration,
      startTime: Date.now(),
      namespace
    }

    stateManager?.setPluginState?.('ai-monitor-pause', pauseInfo)

    activePause = setTimeout(() => {
      stateManager?.setPluginState?.('ai-monitor-pause', { paused: false })
      logger.info(`[AI-MONITOR] Auto-resuming loop after pause: ${reason}`)
    }, duration)

    await stopMonitoring()

    logger.info(`[AI-MONITOR] Loop paused. Auto-resume in ${duration}ms`)

    await new Promise(resolve => setTimeout(resolve, duration))

    const currentPause = stateManager?.getPluginState?.('ai-monitor-pause')
    if (currentPause?.paused) {
      logger.info(`[AI-MONITOR] Resuming loop after user/system intervention`)
      stateManager?.setPluginState?.('ai-monitor-pause', { paused: false })
      await resumeMonitoring()
    }

    return
  } catch (error) {
    logger.error(`[AI-MONITOR] Failed to pause loop: ${error}`)
    throw error
  }
}

export async function isPaused(options: ActionExecutorOptions): Promise<boolean> {
  const pauseInfo = options.stateManager?.getPluginState?.('ai-monitor-pause')
  return pauseInfo?.paused === true
}

export async function clearPause(options: ActionExecutorOptions): Promise<void> {
  options.stateManager?.setPluginState?.('ai-monitor-pause', { paused: false })
  if (activePause) {
    clearTimeout(activePause)
    activePause = null
  }
  logger.info('[AI-MONITOR] Clearing active pause')
}

export async function executeNotification(
  severity: Severity,
  message: string,
  options: ActionExecutorOptions & {
    taskId?: string
    taskTitle?: string
    patternName?: string
    additionalContext?: string
  }
): Promise<void> {
  const {
    taskId: taskIdOption,
    taskTitle: taskTitleOption,
    patternName: patternNameOption,
    additionalContext: additionalContextOption
  } = options

  const context: string[] = []
  if (severity) context.push(`Severity: ${severity}`)
  if (patternNameOption) context.push(`Pattern: ${patternNameOption}`)
  if (taskIdOption) context.push(`Task: ${taskIdOption}`)
  if (taskTitleOption) context.push(`Task Title: ${taskTitleOption}`)
  if (additionalContextOption) context.push(additionalContextOption)

  const logMessage = [
    `ðŸ”” NOTIFICATION (${severity})`,
    ...context,
    '',
    message,
    ''
  ].join('\n')

  logger.warn(logMessage)

  await stopMonitoring()
}

export async function executeLLMAnalysis(
  error: string,
  _context: string,
  _options: ActionExecutorOptions
): Promise<{ cause?: string; severity: Severity; suggestedFix?: string }> {
  try {
    if (error.includes('timeout') || error.includes('ETIMEDOUT')) {
      return {
        severity: 'HIGH',
        suggestedFix: 'Check API rate limits and increase timeout configuration'
      }
    }
    if (error.includes('permission') || error.includes('EACCES')) {
      return {
        severity: 'ERROR',
        suggestedFix: 'Check file permissions and retry'
      }
    }
    return {
      severity: 'MEDIUM',
      cause: 'Unknown error - requires manual inspection'
    }
  } catch (error) {
    logger.error(`[AI-MONITOR] LLM analysis failed: ${error}`)
    throw error
  }
}

export async function executeEnhanceTask(
  taskId: string,
  enhancement: {
    prdAdditions?: {
      context?: string
      approachHints?: string[]
    }
    testScaffolding?: string
  },
  _options: ActionExecutorOptions
): Promise<void> {
  try {
    const prdPath = path.join(process.cwd(), '.specs', 'tasks', `${taskId}.md`)
    const prdContent = await readFile(prdPath, 'utf-8')

    const enhancedContent = applyEnhancements(prdContent, enhancement)

    await writeFile(prdPath, enhancedContent, 'utf-8')
    logger.info(`Enhanced PRD for task ${taskId}`)
  } catch (error) {
    logger.error(`Failed to enhance task ${taskId}: ${error}`)
    throw error
  }
}

export async function executeCircuitBreak(
  failureCount: number,
  _options: ActionExecutorOptions
): Promise<void> {
  logger.error(`[AI-MONITOR] Circuit breaker activated after ${failureCount} consecutive failures`)
  logger.error('[AI-MONITOR] Manual intervention required to reset')
}

async function fileExists(filePath: string): Promise<boolean> {
  try {
    await fs.promises.access(filePath)
    return true
  } catch {
    return false
  }
}

async function ensureDir(dir: string): Promise<void> {
  await fs.promises.mkdir(dir, { recursive: true })
}

async function writeFile(filePath: string, content: string, encoding: BufferEncoding): Promise<void> {
  await fs.promises.writeFile(filePath, content, { encoding })
}

async function readFile(filePath: string, encoding: BufferEncoding): Promise<string> {
  return await fs.promises.readFile(filePath, { encoding })
}

async function updateTaskDescription(
  taskId: string,
  description: string,
  tasksJsonPath: string
): Promise<void> {
  try {
    if (!(await fileExists(tasksJsonPath))) {
      return
    }

    const tasksData = JSON.parse(await readFile(tasksJsonPath, 'utf-8'))
    const taskEntry = tasksData.tasks?.find((t: { id?: string }) => t.id === taskId)

    if (taskEntry && !taskEntry.description) {
      taskEntry.description = description
      await writeFile(tasksJsonPath, JSON.stringify(tasksData, null, 2), 'utf-8')
      logger.info(`Updated task description in ${tasksJsonPath}`)
    }
  } catch (error) {
    logger.debug(`Failed to update task description: ${error}`)
  }
}

function applyEnhancements(content: string, enhancement: { prdAdditions?: { context?: string; approachHints?: string[] }; testScaffolding?: string }): string {
  if (!enhancement.prdAdditions) {
    return content
  }

  const additions = enhancement.prdAdditions

  if (additions.context) {
    content = content.replace(
      '## Requirements',
      `## Requirements\n\n**Context from AI Monitor:**\n${additions.context}\n\n## Requirements`
    )
  }

  if (additions.approachHints && additions.approachHints.length > 0) {
    const hints = additions.approachHints.join('\n- ')
    content = content.replace(
      '## Requirements',
      `## Requirements\n- ${hints}\n\n## Requirements`
    )
  }

  if (enhancement.testScaffolding) {
    content = content.replace(
      '## Notes',
      `## Test Scaffolding\n\`\`\`\`\n${enhancement.testScaffolding}\n\`\`\`\n\n## Notes`
    )
  }

  return content
}

async function stopMonitoring(): Promise<void> {
  logger.debug('[AI-MONITOR] Stopping monitoring activities')
}

async function resumeMonitoring(): Promise<void> {
  logger.debug('[AI-MONITOR] Resuming monitoring activities')
}
